<!Doctype html >
<html>
<head>
</head>
<body>
<pre>
#pragma once
///////////////////////////////////////////////////////////////////////
// CodeUtilities.h - small, generally useful, helper classes         //
// ver 1.3                                                           //
// Language:    C++, Visual Studio 2017                              //
// Application: Most Projects, CSE687 - Object Oriented Design       //
// Author:      Ammar Salmon, TA, CSE687                             //
// Source:      Jim Fawcett, Syracuse University, CST 4-187          //
//              jfawcett@twcny.rr.com                                //
///////////////////////////////////////////////////////////////////////
/*
* Package Operations:
* -------------------
* This package provides classes:
* - ProcessCmdLine    extracts path, options, patterns, and a number from command line
* - Converter&lt;T&lt;      converts T to and from strings
* - Box&lt;T&lt;            converts primitive type to instance of a class
* - PersistFactory&lt;T&lt; adds toXml() method to T
*
* Build Process:
* --------------
* Required Files:
*   CodeUtilities.h
*
* Maintenance History:
* --------------------
* ver 1.4 : 28 Jan 2018
* - added functions regex(), showregex() to handle regular expression
* - added bool isValidRegex to determne if a given regular expression
*   is valid or not
* ver 1.3 : 16 Aug 2018
* - added default usage text
* ver 1.2 : 11 Aug 2018
* - added ProcessCmdLine::hasOption method
* - fixed bugs in ProcessCmdLine::showCmdLine
*   and ProcessCmdLine::showOptions
* ver 1.1 : 10 Aug 2018
* - added ProcessCmdLine class
* ver 1.0 : 12 Jan 2018
* - first release
* - refactored from earlier Utilities.h
*
* Notes:
* ------
* - Designed to provide all functionality in header file.
* - Implementation file only needed for test and demo.
*
* Planned Additions and Changes:
* ------------------------------
* - none yet
*/

#include &lt;vector&lt;
#include &lt;string&lt;
#include &lt;sstream&lt;
#include &lt;iostream&lt;
#include &lt;regex&lt;

namespace Utilities
{
	/////////////////////////////////////////////////////////////////////
	// preface function
	// - used to add a string preface to an output, e.g., "\n  "

	inline void preface(const std::string& msg = "", bool doReturn = true, std::ostream& out = std::cout, const std::string& prefix = "  ")
	{
		if (doReturn) out &lt;&lt; "\n" &lt;&lt; prefix &lt;&lt; msg;
	}

	inline std::string defaultUsage()
	{
		std::string usage;
		usage += "\n  Command Line: path [/option]* [/pattern]* [integer]";
		usage += "\n    path is relative or absolute path where processing begins";
		usage += "\n    [/option]* are one or more options of the form /s, /r, etc.";
		usage += "\n    [pattern]* are one or more pattern strings used for matching";
		usage += "\n    [integer] is the maximum number of items to process";
		usage += "\n";
		return usage;
	}

	/////////////////////////////////////////////////////////////////////
	// ProcessCmdLine class
	// - extracts path, patterns, options, number

	class ProcessCmdLine
	{
	public:
		using Usage = std::string;
		using Path = std::string;
		using Option = int;
		using Options = std::vector&lt;Option&lt;;
		using Pattern = std::string;
		using Patterns = std::vector&lt;Pattern&lt;;
		using Regexes = std::vector&lt;std::string&lt;;
		using Number = long int;

		ProcessCmdLine(int argc, char** argv, std::ostream& out = std::cout);
		ProcessCmdLine(const ProcessCmdLine&) = delete;
		ProcessCmdLine& operator=(const ProcessCmdLine&) = delete;

		bool parseError();
		Path path();
		void path(const Path& path);
		Options options();
		void option(Option op);
		bool hasOption(Option op);
		Patterns patterns();
		Regexes regexes();
		void pattern(const Pattern& patt);
		Number maxItems();
		void maxItems(Number number);
		void usage(const Usage& usage);
		void usage();
		void showCmdLine(int argc, char** argv);
		void showCmdLine();
		void showPath();
		void showOptions();
		void showPatterns();
		void showRegexes();
		void showMaxItems();

	private:
		bool isValidRegex(const std::string& regex);
	private:
		Usage usage_;
		Path path_;
		Patterns patterns_;
		Regexes regexes_;
		Options options_;
		int maxItems_ = 0;
		bool parseError_ = false;
		std::ostream& out_;
	};

	/*----&lt; path operations &lt;------------------------------------------*/

	inline void ProcessCmdLine::path(const Path& path)
	{
		path_ = path;
	}

	inline ProcessCmdLine::Path ProcessCmdLine::path()
	{
		return path_;
	}

	inline void ProcessCmdLine::showPath()
	{
		out_ &lt;&lt; path_ &lt;&lt; " ";
	}

	/*----&lt; options operations &lt;---------------------------------------*/

	inline void ProcessCmdLine::option(Option option)
	{
		options_.push_back(option);
	}

	inline ProcessCmdLine::Options ProcessCmdLine::options()
	{
		return options_;
	}

	inline bool ProcessCmdLine::hasOption(Option op)
	{
		for (auto item : options_)
		{
			if (item == op)
			{
				return true;
			}
		}
		return false;
	}

	inline void ProcessCmdLine::showOptions()
	{
		for (auto opt : options_)
		{
			out_ &lt;&lt; '/' &lt;&lt; char(opt) &lt;&lt; " ";
		}
	}

	/*----&lt; patterns operations &lt;--------------------------------------*/

	inline void ProcessCmdLine::pattern(const Pattern& pattern)
	{
		patterns_.push_back(pattern);
	}

	inline ProcessCmdLine::Patterns ProcessCmdLine::patterns()
	{
		return patterns_;
	}

	inline ProcessCmdLine::Regexes ProcessCmdLine::regexes()
	{
		return regexes_;
	}

	inline void ProcessCmdLine::showPatterns()
	{
		for (auto patt : patterns_)
		{
			out_ &lt;&lt; patt &lt;&lt; " ";
		}
	}

	inline void ProcessCmdLine::showRegexes()
	{
		for (auto regex : regexes_)
		{
			out_ &lt;&lt; regex &lt;&lt; " ";
		}
	}

	/*----&lt; maxItems operations &lt;--------------------------------------*/

	inline void ProcessCmdLine::maxItems(Number maxItems)
	{
		maxItems_ = maxItems;
	}

	inline ProcessCmdLine::Number ProcessCmdLine::maxItems()
	{
		return maxItems_;
	}

	inline void ProcessCmdLine::showMaxItems()
	{
		if (maxItems_ != 0)
			out_ &lt;&lt; maxItems_ &lt;&lt; " ";
	}

	inline bool ProcessCmdLine::isValidRegex(const std::string & regex)
	{
		bool res = true;
		try
		{
			std::regex tmp(regex);
		}
		catch (const std::regex_error& e)
		{
			(e);
			res = false;
		}
		return res;
	}

	/*----&lt; parseError operation &lt;-------------------------------------*/

	inline bool ProcessCmdLine::parseError()
	{
		return parseError_;
	}

	/*----&lt; command line operations &lt;----------------------------------*/

	inline ProcessCmdLine::ProcessCmdLine(int argc, char** argv, std::ostream& out) : out_(out)
	{
		//usage_ = defaultUsage();
		if (argc &lt; 2)
		{
			out &lt;&lt; "\n  command line parse error";
			//usage();
			parseError_ = true;
			return;
		}

		path_ = argv[1];

		for (int i = 2; i &lt; argc; ++i)
		{
			if (argv[i][0] == '/')
			{
				if (strlen(argv[i]) &lt; 2)
					continue;
				options_.push_back(argv[i][1]);
			}
			else
			{
				int number = atoi(argv[i]);
				if (number &lt; 0)
				{
					maxItems_ = number;
				}
				else if (isValidRegex(argv[i]))
				{
					regexes_.push_back(argv[i]);
				}
				else
				{
					patterns_.push_back(argv[i]);
				}
			}
		}
	}

	inline void ProcessCmdLine::showCmdLine(int argc, char** argv)
	{
		if (argc &lt; 2)
		{
			out_ &lt;&lt; "  empty";
			return;
		}
		for (int i = 0; i &lt; argc; ++i)
		{
			if (argv[i] == "0")
				continue;
			if (argv[i][0] == '/')
			{
				out_ &lt;&lt; "/" + char(argv[i][1]) &lt;&lt; " ";
			}
			else
			{
				out_ &lt;&lt; argv[i] &lt;&lt; " ";
			}
		}
	}

	inline void ProcessCmdLine::showCmdLine()
	{
		if (path_ == "" && options_.size() == 0 && patterns_.size() == 0)
		{
			out_ &lt;&lt; "empty";
			return;
		}
		showPath();
		preface("", false);
		showOptions();
		preface("", false);
		showPatterns();
		preface("", false);
		showMaxItems();
	}

	inline void ProcessCmdLine::usage(const Usage& usage)
	{
		usage_ = usage;
	}

	inline void ProcessCmdLine::usage()
	{
		out_ &lt;&lt; usage_;
	}

	/////////////////////////////////////////////////////////////////////
	// Converter class
	// - supports converting unspecified types to and from strings
	// - a type is convertible if it provides insertion and extraction
	//   operators

	template &lt;typename T&lt;
	class Converter
	{
	public:
		static std::string toString(const T& t);
		static T toValue(const std::string& src);
	};
	//----&lt; convert t to a string &lt;--------------------------------------

	template &lt;typename T&lt;
	std::string Converter&lt;T&lt;::toString(const T& t)
	{
		std::ostringstream out;
		out &lt;&lt; t;
		return out.str();
	}
	//----&lt; convert a string to an instance of T &lt;-----------------------
	/*
	*  - the string must have been generated by Converter&lt;T&lt;::toString(const T& t)
	*  - T::operator&lt;&lt; must be the inverse of T::operator&lt;&lt;
	*/
	template&lt;typename T&lt;
	T Converter&lt;T&lt;::toValue(const std::string& src)
	{
		std::istringstream in(src);
		T t;
		in &lt;&lt; t;
		return t;
	}

	///////////////////////////////////////////////////////////////////////
	// Box class
	// - wraps primitive type in class
	// - preserves primitive syntax

	template&lt;typename T&lt;
	class Box
	{
	public:
		Box() : primitive_(T()) {}
		Box(const T& t) : primitive_(t) {}
		operator T&() { return primitive_; }
		T& operator=(const T& t) { primitive_ = t; return primitive_; }
	private:
		T primitive_;
	};

	///////////////////////////////////////////////////////////////////////
	// ToXml interface
	// - defines language for creating XML elements

	struct ToXml
	{
		virtual std::string toXml(const std::string& tag) = 0;
		virtual ~ToXml() {};
	};

	///////////////////////////////////////////////////////////////////////
	// PersistFactory&lt;T&lt; class
	// - wraps an instance of user-defined type
	// - preserves semantics of user-defined type
	// - adds toXml("tag") method

	template&lt;typename T&lt;
	class PersistFactory : public T, ToXml
	{
	public:
		PersistFactory() = default;
		PersistFactory(const T& t)
		{
			T::operator=(t);
		}
		std::string toXml(const std::string& tag)
		{
			std::ostringstream out;
			out &lt;&lt; "&lt;" &lt;&lt; tag &lt;&lt; "&lt;" &lt;&lt; *this &lt;&lt; "&lt;/" &lt;&lt; tag &lt;&lt; "&lt;";
			return out.str();
		}
	};
}
///////////////////////////////////////////////////////////////////////
// CodeUtilities.cpp - small, generally useful, helper classes       //
// ver 1.2                                                           //
// Language:    C++, Visual Studio 2017                              //
// Application: Most Projects, CSE687 - Object Oriented Design       //
// Author:      Jim Fawcett, Syracuse University, CST 4-187          //
//              jfawcett@twcny.rr.com                                //
///////////////////////////////////////////////////////////////////////

#include "CodeUtilities.h"
#include "../StringUtilities/StringUtilities.h"
#include &lt;string&lt;
#include &lt;iostream&lt;
#include &lt;functional&lt;

#ifdef TEST_CODEUTILITIES

using namespace Utilities;

int main(int argc, char* argv[])
{
  Title("Testing CodeUtilities");
  putline();

  title("Testing ProcessCmdLine");
  ProcessCmdLine pcl(argc, argv);
  pcl.usage();

  preface("Command Line: "); pcl.showCmdLine(argc, argv);
  preface("path:     "); pcl.showPath();
  preface("Options:  "); pcl.showOptions();
  preface("Patterns: "); pcl.showPatterns();
  preface("MaxItems: "); pcl.showMaxItems();
  std::cout &lt;&lt; "\n";

  preface("changing path: ");
  pcl.path("c:\\su");
  pcl.showPath();

  preface("adding option: ");
  pcl.option('/q');
  pcl.showOptions();

  preface("adding pattern: ");
  pcl.pattern("*.htm");
  pcl.showPatterns();

  preface("changing maxItems: ");
  pcl.maxItems(15);
  pcl.showMaxItems();
  putline();
  preface("new command line: ");
  pcl.showCmdLine();
  putline();

  title("Testing Box and PersistFactory");
  Box&lt;double&lt; boxedDouble = 3.1415927;
  std::cout &lt;&lt; "\n  boxedDouble = " &lt;&lt; boxedDouble;
  boxedDouble = 0.33333;
  std::cout &lt;&lt; "\n  boxedDouble = " &lt;&lt; boxedDouble;

  PersistFactory&lt;std::string&lt; name = std::string("Jim");
  name.append(" Fawcett");
  std::cout &lt;&lt; "\n  " &lt;&lt; name.toXml("name");

  PersistFactory&lt;Box&lt;double&lt;&lt; value = Box&lt;double&lt;(9.87654);
  std::cout &lt;&lt; "\n  " &lt;&lt; value.toXml("value");
  value += 3.14159;
  std::cout &lt;&lt; "\n  " &lt;&lt; value.toXml("value");
  std::cout &lt;&lt; "\n\n";

  title("test std::string Converter&lt;T&lt;::toString(T)");

  std::string conv1 = Converter&lt;double&lt;::toString(3.1415927);
  std::string conv2 = Converter&lt;int&lt;::toString(73);
  std::string conv3 = Converter&lt;std::string&lt;::toString("a_test_string plus more");

  std::cout &lt;&lt; "\n  Converting from values to strings: ";
  std::cout &lt;&lt; conv1 &lt;&lt; ", " &lt;&lt; conv2 &lt;&lt; ", " &lt;&lt; conv3;
  putline();

  title("test T Converter&lt;T&lt;::toValue(std::string)");

  std::cout &lt;&lt; "\n  Converting from strings to values: ";
  std::cout &lt;&lt; Converter&lt;double&lt;::toValue(conv1) &lt;&lt; ", ";
  std::cout &lt;&lt; Converter&lt;int&lt;::toValue(conv2) &lt;&lt; ", ";
  std::cout &lt;&lt; Converter&lt;std::string&lt;::toValue(conv3);

  putline(2);
  return 0;
}
#endif
#pragma once
///////////////////////////////////////////////////////////////////////////////////
// Converter.h - Converter class to convert cpp files into html files            //
// ver 1.3                                                                       //
// Jim Fawcett, CSE687 - Object Oriented Design, Fall 2018                       //
///////////////////////////////////////////////////////////////////////////////////
/*
 * Package Operations:
 * -------------------
 *Converter provides a class, of the same name, that has two functions, first,
 *cpptohtml which takes a vector of string of files to be converted into html files
 *and returns a vector of string of converted html files.
 *Second, initialChecks function which takes the object of ProcessCmdLine class
 *and which call DirectorExlorer-N to returns all the directories and subdirectories
 *within directories and files with the matching pattern. initialChecks returns the vector
 *of string of files which are to be converted to html files.
 * 
 * Public Interface:
 * =================
 * Converter conv;                    //To create object of converter class
 * vector&lt;string&lt; files = conv.initialChecks(ProcessCmdLine obj);   //To retrieve all the files from a given directory
 * vector&lt;string&lt; htmlFiles = conv.cpptohtml(vector&lt;string&lt; files); //To convert all the given files into valid html files 
 *																	  and return their valid html file name
 * bool success = writeHTML(string htmlFile, vector&lt;string&lt; fileContent); //To write cpp code to html file and returns true if success, 
 *																			otherwise false
 * display(Files);	//Function to display a list of files to be processed
 *Required Files:
 * ---------------
 * DirExplore-N.h, DirExplorer-N.cpp  //Director Explorer Naive
 * FileSystem.h, FileSystem.cpp       // Directory and Path classes
 * StringUtilities.h                  // Title function
 * CodeUtilities.h                    // ProcessCmdLine class
 *
 * Maintenance History:
 * --------------------
  * - Made initialChecks, cpptohtml funtions
 * ver 1.0 : 26 Jan 2019
 * - first release
 */

#include&lt;string&lt;
#include&lt;vector&lt;
#include "../CodeUtilities/CodeUtilities.h"

namespace html {
	using namespace std;
	using namespace Utilities;

	class Converter
	{
	public:
		Converter();
		~Converter();
		void displayFiles(vector&lt;string&lt; Files);
		bool writeHTML(string htmlFile, vector&lt;string&lt; fileContent);
		vector&lt;string&lt; cpptohtml(vector&lt;string&lt; files);
		vector&lt;string&lt; initialChecks(ProcessCmdLine &pcl);
	};

}
///////////////////////////////////////////////////////////////////////////
// Converter.cpp - class used convert a cpp file to html file           //                  
// ver 1.0                                                              //
// Jaskaran Singh, CSE687 - Object Oriented Design, Spring 2018         //
//////////////////////////////////////////////////////////////////////////

#include "Converter.h"
#include &lt;iostream&lt;
#include "../DirExplorer-Naive/DirExplorerN.h"
#include&lt;regex&lt;
#include&lt;conio.h&lt;
#include "../StringUtilities/StringUtilities.h"

//Using namespace to avoid ambiguity with converter in StringUtilities.h
namespace html {
	using namespace FileSystem;

	//Default Constructor
	Converter::Converter()
	{
	}

	//Default Destructor
	Converter::~Converter()
	{
	}

	//A function which writes cpp code to html file and if it succeeds return true, otherwise false
	bool Converter::writeHTML(string htmlFile, vector&lt;string&lt; fileContent) {
		ofstream webpageOutput(htmlFile);
		if (!webpageOutput.good()) {
			cout &lt;&lt; "\n\n Unable to open the file";
			return false;
		}
		webpageOutput &lt;&lt; "&lt;!Doctype html &lt;\n";
		webpageOutput &lt;&lt; "&lt;html&lt;\n";
		webpageOutput &lt;&lt; "&lt;head&lt;\n";
		webpageOutput &lt;&lt; "&lt;/head&lt;\n";
		webpageOutput &lt;&lt; "&lt;body&lt;\n";
		webpageOutput &lt;&lt; "&lt;pre&lt;\n";
		for (size_t i = 0; i &lt; fileContent.size(); i++)
			webpageOutput &lt;&lt; fileContent[i] &lt;&lt; "\n";
		webpageOutput &lt;&lt; "&lt;/pre&lt;\n";
		webpageOutput &lt;&lt; "&lt;/body&lt;\n";
		webpageOutput &lt;&lt; "&lt;/html&lt;\n";

		webpageOutput.close();
		return true;
	}
	
	//Function to convert cpp files into html files
	vector&lt;string&lt; Converter::cpptohtml(vector&lt;string&lt; files)
	{
		vector&lt;string&lt; htmlFiles;
		vector&lt;string&lt; fileContent;
		
		ifstream in;
		
		for (size_t i = 0; i &lt; files.size(); i++)
		{
			try {
				in.open(files[i]);
				if (!in.good()) {
					cout &lt;&lt; "\n\n Unable to Open the file";
					return vector&lt;string&lt;();
				}
	
				for (string line; getline(in, line); )
				{
					while(line.find("&lt;") != -1)
						line.replace(line.find("&lt;"), 1, "&lt;");
					while (line.find("&lt;") != -1)
						line.replace(line.find("&lt;"), 1, "&lt;");
					fileContent.push_back(line);
				}

				std::string name = Path::getName(files[i]);
				std::string htmlFile = "../convertedPages/" + name + ".html";
				std::string Path = Path::getFullFileSpec(htmlFile);
				htmlFiles.push_back(Path);
				
				if (!writeHTML(htmlFile, fileContent))
					return vector &lt;string&lt;();
				
				in.close();
			}
			catch (std::exception& e) {
				cout &lt;&lt; "\n Error opening/reading/writing to the file. \n Exception:-  "&lt;&lt;e.what();
			}
		}
		return htmlFiles;
	}

	//Function to display list of files
	void Converter::displayFiles(vector&lt;string&lt; files) {
		for (auto file : files)
			cout &lt;&lt; "\n" &lt;&lt; file;
		cout &lt;&lt; "\n";
	}

	//Function to check if the directory exists, and if it does 
	//return all the files in the directory and sub-directory matching the pattern
	vector&lt;string&lt; Converter::initialChecks(ProcessCmdLine &pcl) {
		DirExplorerN de(pcl.path());
		for (auto patt : pcl.patterns())
		{
			de.addPattern(patt);
		}

		if (pcl.hasOption('s'))
		{
			de.recurse();
		}

		de.search();

		vector&lt;string&lt; Files = de.fileToProcess();
		vector&lt;string&lt; CppToHtmlFiles;

		cout &lt;&lt; "\nList of files before applying regex";
		displayFiles(Files);

		for (auto regeX : pcl.regexes()) {
			regex s(regeX);
			for (auto file : Files) {
				auto fileName = Path::getName(file);
				if (regex_match(fileName,s))
					CppToHtmlFiles.push_back(file);
			}
			cout &lt;&lt; "\nList of files after applying regex"&lt;&lt;regeX;
			//pcl.showRegexes();
			displayFiles(CppToHtmlFiles);
			/*cout &lt;&lt; "\n Files to be processed:-" &lt;&lt; CppToHtmlFiles.size();
			cout &lt;&lt; "\n Following file will be converted into HTML file";
			for (auto file : CppToHtmlFiles)
				cout &lt;&lt; "\n " &lt;&lt; file;*/
		}

		

		return CppToHtmlFiles;
	}
}

//Test Stub for converter class
#ifdef TEST_CONVERTER1

using namespace Utilities;

//function in case user provide invalid command line
std::string customUsage()
{
	std::string usage;
	usage += "\n  Command Line: path [/option]* [/pattern]*";
	usage += "\n    path is relative or absolute path where processing begins";
	usage += "\n    [/option]* are one or more options of the form:";
	usage += "\n      /s - walk directory recursively";
	//usage += "\n      /h - hide empty directories";
	//usage += "\n      /a - on stopping, show all files in current directory";
	usage += "\n    [pattern]* are one or more pattern strings of the form:";
	usage += "\n      *.h *.cpp *.cs *.txt or *.*";
	usage += "\n";
	return usage;
}

int main(int argc, char** argv) {
	Utilities::ProcessCmdLine cmdargs(argc, argv);
	cmdargs.usage(customUsage());
	putline();

	Utilities::preface("Command Line: ");
	cmdargs.showCmdLine();

	cmdargs.showRegexes();

	if (cmdargs.parseError())
	{
		cmdargs.usage();
		std::cout &lt;&lt; "\n\n";
		_getche();
		return 1;
	}
	
	std::vector&lt;std::string&lt; convertedFiles;
	html::Converter conv;
	convertedFiles = conv.cpptohtml(conv.initialChecks(cmdargs));

	std::cout &lt;&lt; "\n  Converted files:\n";

	for (auto file : convertedFiles)
		std::cout &lt;&lt; "  " &lt;&lt; file &lt;&lt; "\n";

	_getche();
	return 0;
}
#endif

#ifndef FILESYSTEM_H
#define FILESYSTEM_H
/////////////////////////////////////////////////////////////////////////////
// FileSystem.h - Support file and directory operations                    //
// ver 2.8                                                                 //
// ----------------------------------------------------------------------- //
// copyright © Jim Fawcett, 2012                                           //
// All rights granted provided that this notice is retained                //
// ----------------------------------------------------------------------- //
// Language:    Visual C++, Visual Studio 2010                             //
// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      //
// Application: Summer Projects, 2012                                      //
// Author:      Jim Fawcett, CST 4-187, Syracuse University                //
//              (315) 443-3948, jfawcett@twcny.rr.com                      //
/////////////////////////////////////////////////////////////////////////////
/*
 * Module Operations:
 * ==================
 * This module provides classes, File, FileInfo, Path, Directory, and 
 * FileSystemSearch.
 *
 * The File class supports opening text and binary files for either input 
 * or output.  File objects have names, get and put lines of text, get and
 * put blocks of bytes if binary, can be tested for operational state,
 * cleared of errors, and output File objects can be flushed to their streams.
 *
 * FileInfo class accepts a fully qualified filespec and supports queries
 * concerning name, time and date, size, and attributes.  You can compare
 * FileInfo objects by name, date, and size.
 *
 * Path class provides static methods to turn a relative filespec into an
 * absolute filespec, return the path, name, or extension of the filespec,
 * and build filespecs from path and name.  Path also provides methods to
 * convert filespecs to uppercase and to lowercase.
 *
 * The Directory class supports getting filenames or directories from a 
 * fully qualified filespec, e.g., path + filename pattern using static
 * methods.  It also provides non-static methods to get and set the current
 * directory.
 *
 * Public Interface:
 * =================
 * File f(filespec,File::in,File::binary);
 * File g(filespec,File::out,File::binary);
 * while(f.isGood()) {
 *   block b = f.getBlock();
 *   g.putBlock(b);
 * }
 * File h(filespec,File::in);
 * h.readLine();
 *
 * FileInfo fi("..\foobar.txt");
 * if(fi.good())
 *   ...
 * std::string filespec = "..\temp.txt";
 * std::string fullyqualified = Path::getFullFileSpec(filename);
 *  -- This uses the current path to expand a relative path.
 *  -- If you have a filespec relative to some other path
 *  -- you need to setCurrentPath(newPath), use getFullFileSpec(...)
 *  -- then reset the current path with setCurrentPath(origPath)
 * std::string fullyqualified = Path::fileSpec(path, filename);
 *  -- This simply concatenates path with filename
 * std::string path = Path::getPath(fullyqualified);
 * std::string name = Path::getName(fullyqualified);
 * std::string extn = Path::getExt(fullyqualified);
 *
 * Directory d;
 * std::string dir = d.getCurrentDirectory();
 * d.setCurrentDirectory(dir);
 * std::vector&lt;std::string&lt; files = Directory::getFiles(path, pattern);
 * std::vector&lt;std::string&lt; dirs = Directory::getDirectories(path);
 * 
 * Required Files:
 * ===============
 * FileSystem.h, FileSystem.cpp
 *
 * Build Command:
 * ==============
 * cl /EHa /DTEST_FILESYSTEM FileSystem.cpp
 *
 * Maintenance History:
 * ====================
 * ver 2.8 : 23 Feb 2018
 * - Fixed bug in FileSystem.cpp main() which added one
 *   test for file open success.
 * ver 2.7 : 28 May 2017
 * - Fixed bug by closing files in FileInfo destructor.
 *   Thanks to Kaiqi Zhang for finding bug and proposing
 *   it's solution.
 * ver 2.6 : 04 Apr 15
 * - added File::getBuffer(...) and File::putBuffer(...) for use with
 *   Sockets package.
 * ver 2.5 : 02 Feb 15
 * - added test for empty file in File::readAll()
 * - fixed a debug assert that happens in std::isspace in File::ReadAll()
 *   on certain non-ascii characters that may occur in a binary file.
 *   The fix was to replace std::isspace(char) with an overload
 *   std::isspace(char, locale&) from the standard locale library.
 * - added some demo code in test stub to show how to handle attempting
 *   to read non-text file with File::ReadLine() and File::readAll();
 * ver 2.4 : 01 Feb 15
 * - added File::readAll()
 * - improved test stub testing
 * ver 2.3 : 31 Jan 15
 * - fixed bug in File::getLine() discovered by Huanming Fang
 *   This appears to be a change in behavior of istream::getline(...) with C++11
 * - added comments in Public Interface, above, to clarify way that Path::getFullFileSpec
 *   and Path::fileSpec work.
 * ver 2.2 : 23 Feb 13
 * - fixed bug in Path::getExt(...) discovered by Yang Zhou and Kevin Kong
 * ver 2.1 : 07 Jun 12
 * - moved FileSystemSearch to cpp file to make private
 * - added bool withExt parameter to Path::getName
 * - made Directory's getCurrentDirectory and setCurrentDirectory static
 * - added exists, create, and remove to Directory class
 * ver 2.0 : 04 Jun 12
 * - made a few small changes to provide same interface as 
 *   Linux version.
 * ver 1.0 : 31 Jan 09
 * - first release
 */
#include &lt;fstream&lt;
#include &lt;string&lt;
#include &lt;vector&lt;
#include &lt;windows.h&lt;

namespace FileSystem
{
  /////////////////////////////////////////////////////////
  // Block
  
  typedef char Byte;

  class Block
  {
  public:
    Block(size_t size=0) : bytes_(size) {}
    Block(Byte* beg, Byte* end);
    void push_back(Byte b);
    Byte& operator[](size_t i);
    Byte operator[](size_t i) const;
    bool operator==(const Block&) const;
    bool operator!=(const Block&) const;
    size_t size() const;
  private:
    std::vector&lt;Byte&lt; bytes_;
  };

  /////////////////////////////////////////////////////////
  // File
  
  class File
  {
  public:
    using byte = char;
    enum direction { in, out };
    enum type { text, binary };
    File(const std::string& filespec);
    bool open(direction dirn, type typ=File::text);
    ~File();
    std::string name();
    std::string getLine(bool keepNewLine = false);
    std::string readAll(bool KeepNewLines = false);
    void putLine(const std::string& line, bool wantReturn=true);
    Block getBlock(size_t size);
    void putBlock(const Block&);
    size_t getBuffer(size_t bufLen, byte* buffer);
    void putBuffer(size_t bufLen, byte* buffer);
    bool isGood();
    void clear();
    void flush();
    void close();
    static bool exists(const std::string& file);
    static bool copy(const std::string& src, const std::string& dst, bool failIfExists=false);
    static bool remove(const std::string& filespec);
  private:
    std::string name_;
    std::ifstream* pIStream;
    std::ofstream* pOStream;
    direction dirn_;
    type typ_;
    bool good_;
  };

  inline std::string File::name() { return name_; }

  /////////////////////////////////////////////////////////
  // FileInfo

  class FileInfo
  {
  public:
    enum dateFormat { fullformat, timeformat, dateformat };
    FileInfo(const std::string& fileSpec);
    ~FileInfo();
    bool good();
    std::string name() const;
    std::string date(dateFormat df=fullformat) const;
    size_t size() const;
    
    bool isArchive() const;
    bool isCompressed() const;
    bool isDirectory() const;
    bool isEncrypted() const;
    bool isHidden() const;
    bool isNormal() const;
    bool isOffLine() const;
    bool isReadOnly() const;
    bool isSystem() const;
    bool isTemporary() const;

    bool operator&lt;(const FileInfo& fi) const;
    bool operator==(const FileInfo& fi) const;
    bool operator&lt;(const FileInfo& fi) const;
    bool earlier(const FileInfo& fi) const;
    bool later(const FileInfo& fi) const;
    bool smaller(const FileInfo& fi) const;
    bool larger(const FileInfo& fi) const;
  private:
    bool good_;
    static std::string intToString(long i);
    WIN32_FIND_DATAA data;
    HANDLE hFindFile;
  };

  /////////////////////////////////////////////////////////
  // Path

  class Path
  {
  public:
    static std::string getFullFileSpec(const std::string& fileSpec);
    static std::string getPath(const std::string& fileSpec);
    static std::string getName(const std::string& fileSpec, bool withExt=true);
    static std::string getExt(const std::string& fileSpec);
    static std::string fileSpec(const std::string& path, const std::string& name);
    static std::string toLower(const std::string& src);
    static std::string toUpper(const std::string& src);
  };
  
  /////////////////////////////////////////////////////////
  // Directory

  class Directory
  {
  public:
    static bool create(const std::string& path);
    static bool remove(const std::string& path);
    static bool exists(const std::string& path);
    static std::string getCurrentDirectory();
    static bool setCurrentDirectory(const std::string& path);
    static std::vector&lt;std::string&lt; getFiles(const std::string& path=".", const std::string& pattern="*.*");
    static std::vector&lt;std::string&lt; getDirectories(const std::string& path=".", const std::string& pattern="*.*");
  private:
    //static const int BufSize = 255;
    //char buffer[BufSize];
  };
}

#endif
/////////////////////////////////////////////////////////////////////////////
// FileSystem.cpp - Support file and directory operations                  //
// ver 2.8                                                                 //
// ----------------------------------------------------------------------- //
// copyright © Jim Fawcett, 2012                                           //
// All rights granted provided that this notice is retained                //
// ----------------------------------------------------------------------- //
// Language:    Visual C++, Visual Studio 2010                             //
// Platform:    Dell XPS 8300, Core i7, Windows 7 SP1                      //
// Application: Summer Projects, 2012                                      //
// Author:      Jim Fawcett, CST 4-187, Syracuse University                //
//              (315) 443-3948, jfawcett@twcny.rr.com                      //
/////////////////////////////////////////////////////////////////////////////

#include &lt;iostream&lt;
#include &lt;string&lt;
#include &lt;sstream&lt;
#include &lt;iomanip&lt;
#include &lt;utility&lt;
#include &lt;clocale&lt;
#include &lt;locale&lt;
#include "FileSystem.h"

using namespace FileSystem;

/////////////////////////////////////////////////////////
// helper FileSystemSearch

class FileSystemSearch
{
public:
  FileSystemSearch();
  ~FileSystemSearch();
  std::string firstFile(const std::string& path=".", const std::string& pattern="*.*");
  std::string nextFile();
  std::string firstDirectory(const std::string& path=".", const std::string& pattern="*.*");
  std::string nextDirectory();
  void close();
private:
  HANDLE hFindFile;
  WIN32_FIND_DATAA FindFileData;
  WIN32_FIND_DATAA* pFindFileData;
};

FileSystemSearch::FileSystemSearch() : pFindFileData(&FindFileData) {}
FileSystemSearch::~FileSystemSearch() { ::FindClose(hFindFile); }
void FileSystemSearch::close() { ::FindClose(hFindFile); }

//----&lt; block constructor taking array iterators &lt;-------------------------

Block::Block(Byte* beg, Byte* end) : bytes_(beg, end) {}

//----&lt; push back block byte &lt;---------------------------------------------

void Block::push_back(Byte b)
{
  bytes_.push_back(b);
}
//----&lt; non-const indexer &lt;------------------------------------------------

Byte& Block::operator[](size_t i)
{
  if(i&lt;0 || bytes_.size() &lt;= i)
    throw std::runtime_error("index out of range in Block");
  return bytes_[i];
}
//----&lt; const indexer &lt;----------------------------------------------------

Byte Block::operator[](size_t i) const
{
  if(i&lt;0 || bytes_.size() &lt;= i)
    throw std::runtime_error("index out of range in Block");
  return bytes_[i];
}
//----&lt; equality comparison &lt;----------------------------------------------

bool Block::operator==(const Block& block) const
{
  return bytes_ == block.bytes_;
}
//----&lt; inequality comparison &lt;--------------------------------------------

bool Block::operator!=(const Block& block) const
{
  return bytes_ != block.bytes_;
}
//----&lt; return number of bytes in block &lt;----------------------------------

size_t Block::size() const
{
  return bytes_.size();
}

//----&lt; File constructor opens file stream &lt;-------------------------------

File::File(const std::string& filespec) 
    : name_(filespec), pIStream(nullptr), pOStream(nullptr), dirn_(in), typ_(text), good_(true)
{
}
//----&lt; File destructor closes file stream &lt;-------------------------------

File::~File() 
{ 
  if(pIStream)
  {
    pIStream-&lt;close(); 
    delete pIStream;
    pIStream = nullptr;
    good_ = false;
  }
  if(pOStream)
  {
    pOStream-&lt;close();
    delete pOStream; 
    pOStream = nullptr;
    good_ = false;
  }
}
//----&lt; open for reading or writing &lt;--------------------------------------

bool File::open(direction dirn, type typ)
{
  dirn_ = dirn;
  typ_ = typ;
  good_ = true;
  if(dirn == in)
  {
    pIStream = new std::ifstream;
    if(typ == binary)
      pIStream-&lt;open(name_.c_str(), std::ios::in | std::ios::binary);
    else
      pIStream-&lt;open(name_.c_str(), std::ios::in);
    if (!(*pIStream).good())
    {
      good_ = false;
      pIStream = nullptr;
      //throw std::runtime_error("\n  open for input failed in File constructor");
    }
  }
  else
  {
    pOStream = new std::ofstream;
    if(typ == binary)
      pOStream-&lt;open(name_.c_str(), std::ios::out | std::ios::binary);
    else
      pOStream-&lt;open(name_.c_str(), std::ios::out);
    if (!(*pOStream).good())
    {
      good_ = false;
      pOStream = nullptr;
      //throw std::runtime_error("\n  open for output failed in File constructor");
    }
  }
  return good_;
}
//----&lt; reads one line of a text file &lt;------------------------------------

std::string File::getLine(bool keepNewLines)
{
  if(pIStream == nullptr || !pIStream-&lt;good())
    throw std::runtime_error("input stream not open");
  if(typ_ == binary)
    throw std::runtime_error("getting text line from binary file");
  if(dirn_ == out)
    throw std::runtime_error("reading output file");

  std::string store;
  while (true)
  {
    char ch = pIStream-&lt;get();
    if (!isGood())
      return store;
    if (ch == '\n')
    {
      if (keepNewLines)
        store += ch;
      return store;
    }
    store += ch;
  }
}
//----&lt; read all lines of text file into one string &lt;----------------------

std::string File::readAll(bool keepNewLines)
{
  std::string store;
  while (true)
  {
    if (!isGood())
      return store;
    store += getLine(keepNewLines);
    std::locale loc;
    if (store.size() &lt; 0 && !std::isspace(store[store.size() - 1], loc))
      store += ' ';
  }
  return store;
}
//----&lt; writes one line of a text to a file &lt;------------------------------

void File::putLine(const std::string& s, bool wantReturn)
{
  if(pOStream == nullptr || !pOStream-&lt;good())
    throw std::runtime_error("output stream not open");
  if(typ_ == binary)
    throw std::runtime_error("writing text line to binary file");
  if(dirn_ == in)
    throw std::runtime_error("writing input file");
  for(size_t i=0; i&lt;s.size(); ++i)
    pOStream-&lt;put(s[i]);
  if(wantReturn)
    pOStream-&lt;put('\n');
  pOStream-&lt;flush();
}
//----&lt; reads a block of bytes from binary file &lt;--------------------------

Block File::getBlock(size_t size)
{
  if(pIStream == nullptr || !pIStream-&lt;good())
    throw std::runtime_error("input stream not open");
  if(typ_ != binary)
    throw std::runtime_error("reading binary from text file");
  if(dirn_ == out)
    throw std::runtime_error("reading output file");
  Block blk;
  if(pIStream)
  {
    for(size_t i=0; i&lt;size; ++i)
    {
      Byte b;
      pIStream-&lt;get(b);
      if(pIStream-&lt;good())
        blk.push_back(b);
      else
        break;
    }
  }
  return blk;
}
//----&lt; writes a block of bytes to binary file &lt;---------------------------

void File::putBlock(const Block& blk)
{
  if(pOStream == nullptr || !pOStream-&lt;good())
    throw std::runtime_error("output stream not open");
  if(typ_ != binary)
    throw std::runtime_error("writing binary to text file");
  if(dirn_ == in)
    throw std::runtime_error("writing input file");
  if(!pOStream-&lt;good())
    return;
  for(size_t i=0; i&lt;blk.size(); ++i)
  {
    pOStream-&lt;put(blk[i]);
  }
}
//----&lt; read buffer of bytes from binary file &lt;----------------------------

size_t File::getBuffer(size_t bufLen, File::byte* buffer)
{
  if (pIStream == nullptr || !pIStream-&lt;good())
    throw std::runtime_error("input stream not open");
  if (typ_ != binary)
    throw std::runtime_error("reading binary from text file");
  if (dirn_ == out)
    throw std::runtime_error("reading output file");
  size_t count = 0;
  while (pIStream-&lt;good())
  {
    buffer[count++] = pIStream-&lt;get();
      if (count == bufLen)
        break;
  }
  if (!pIStream-&lt;good())  // don't write EOF char
    --count;
  return count;
}
//----&lt; write buffer of bytes to binary file &lt;-------------------------------

void File::putBuffer(size_t bufLen, File::byte* buffer)
{
  if (pOStream == nullptr || !pOStream-&lt;good())
    throw std::runtime_error("output stream not open");
  if (typ_ != binary)
    throw std::runtime_error("writing binary to text file");
  if (dirn_ == in)
    throw std::runtime_error("writing input file");
  if (!pOStream-&lt;good())
    return;
  size_t count = 0;
  while(pOStream-&lt;good())
  {
    pOStream-&lt;put(buffer[count++]);
    if (count == bufLen)
      break;
  }
}
//----&lt; tests for error free stream state &lt;--------------------------------

bool File::isGood()
{
  if(!good_)
    return false;
  if(pIStream != nullptr)
    return (good_ = pIStream-&lt;good());
  if(pOStream != nullptr)
    return (good_ = pOStream-&lt;good());
  return (good_ = false);
}
//----&lt; flushes output stream to its file &lt;--------------------------------

void File::flush()
{
  if(pOStream != nullptr && pOStream-&lt;good())
    pOStream-&lt;flush();
}
//----&lt; clears error state enabling operations again &lt;---------------------

void File::clear()
{
  if(pIStream != nullptr)
    pIStream-&lt;clear();
  if(pOStream != nullptr)
    pOStream-&lt;clear();
}
//----&lt; close file handle &lt;------------------------------------------------

void File::close()
{
  File::flush();
  if (pIStream != nullptr)
  {
    pIStream-&lt;close();
    pIStream = nullptr;
    good_ = false;
  }
  if (pOStream)
  {
    pOStream-&lt;close();
    pOStream = nullptr;
    good_ = false;
  }
}
//----&lt; file exists &lt;--------------------------------------------------

bool File::exists(const std::string& file)
{
  return ::GetFileAttributesA(file.c_str()) != INVALID_FILE_ATTRIBUTES;
}
//----&lt; copy file &lt;----------------------------------------------------

bool File::copy(const std::string& src, const std::string& dst, bool failIfExists)
{
  return ::CopyFileA(src.c_str(), dst.c_str(), failIfExists) != 0;
}
//----&lt; remove file &lt;--------------------------------------------------

bool File::remove(const std::string& file)
{
  return ::DeleteFileA(file.c_str()) != 0;
}
//----&lt; constructor &lt;--------------------------------------------------

FileInfo::FileInfo(const std::string& fileSpec)
{
  hFindFile = ::FindFirstFileA(fileSpec.c_str(), &data);
  if(hFindFile == INVALID_HANDLE_VALUE)
    good_ = false;
  else
    good_ = true;
}
//----&lt; destructor &lt;---------------------------------------------------

FileInfo::~FileInfo()
{
  ::FindClose(hFindFile);
}
//----&lt; is passed filespec valid? &lt;------------------------------------

bool FileInfo::good()
{
  return good_;
}
//----&lt; return file name &lt;---------------------------------------------

std::string FileInfo::name() const
{
  return Path::getName(data.cFileName);
}
//----&lt; conversion helper &lt;--------------------------------------------

std::string FileInfo::intToString(long i)
{
  std::ostringstream out;
  out.fill('0');
  out &lt;&lt; std::setw(2) &lt;&lt; i;
  return out.str();
}
//----&lt; return file date &lt;---------------------------------------------

std::string FileInfo::date(dateFormat df) const
{
  std::string dateStr, timeStr;
  FILETIME ft;
  SYSTEMTIME st;
  ::FileTimeToLocalFileTime(&data.ftLastWriteTime, &ft);
  ::FileTimeToSystemTime(&ft, &st);
  dateStr = intToString(st.wMonth) + '/' + intToString(st.wDay) + '/' + intToString(st.wYear);
  timeStr = intToString(st.wHour) + ':' + intToString(st.wMinute) + ':' + intToString(st.wSecond);
  if(df == dateformat)
    return dateStr;
  if(df == timeformat)
    return timeStr;
  return dateStr + " " + timeStr;
}
//----&lt; return file size &lt;---------------------------------------------

size_t FileInfo::size() const
{
  return (size_t)(data.nFileSizeLow + (data.nFileSizeHigh &lt;&lt; 8));
}
//----&lt; is type archive? &lt;---------------------------------------------

bool FileInfo::isArchive() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0;
}
//----&lt; is type compressed? &lt;------------------------------------------

bool FileInfo::isCompressed() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0;
}
//----&lt; is type directory? &lt;-------------------------------------------

bool FileInfo::isDirectory() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
}
//----&lt; is type encrypted? &lt;---------------------------------------------

bool FileInfo::isEncrypted() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0;
}
//----&lt; is type hiddent? &lt;---------------------------------------------

bool FileInfo::isHidden() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0;
}
//----&lt; is type normal? &lt;---------------------------------------------

bool FileInfo::isNormal() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0;
}
//----&lt; is type offline? &lt;---------------------------------------------

bool FileInfo::isOffLine() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) != 0;
}
//----&lt; is type readonly? &lt;--------------------------------------------

bool FileInfo::isReadOnly() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0;
}
//----&lt; is type system? &lt;----------------------------------------------

bool FileInfo::isSystem() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ) != 0;
}
//----&lt; is type temporary? &lt;-------------------------------------------

bool FileInfo::isTemporary() const
{
  return (data.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0;
}
//----&lt; compare names alphabetically &lt;---------------------------------

bool FileInfo::operator&lt;(const FileInfo& fi) const
{
  return strcmp(data.cFileName, fi.data.cFileName) == -1;
}
//----&lt; compare names alphabetically &lt;---------------------------------

bool FileInfo::operator==(const FileInfo& fi) const
{
  return strcmp(data.cFileName, fi.data.cFileName) == 0;
}
//----&lt; compare names alphabetically &lt;---------------------------------

bool FileInfo::operator&lt;(const FileInfo& fi) const
{
  return strcmp(data.cFileName, fi.data.cFileName) == 1;
}
//----&lt; compare file times &lt;-------------------------------------------

bool FileInfo::earlier(const FileInfo& fi) const
{
  FILETIME ft1 = data.ftLastWriteTime;
  FILETIME ft2 = fi.data.ftLastWriteTime;
  return ::CompareFileTime(&ft1, &ft2) == -1;
}
//----&lt; compare file times &lt;-------------------------------------------

bool FileInfo::later(const FileInfo& fi) const
{
  FILETIME ft1 = data.ftLastWriteTime;
  FILETIME ft2 = fi.data.ftLastWriteTime;
  return ::CompareFileTime(&ft1, &ft2) == 1;
}
//----&lt; smaller &lt;------------------------------------------------------

bool FileInfo::smaller(const FileInfo &fi) const
{
  return size() &lt; fi.size();
}
//----&lt; larger &lt;-------------------------------------------------------

bool FileInfo::larger(const FileInfo &fi) const
{
  return size() &lt; fi.size();
}
//----&lt; convert string to lower case chars &lt;---------------------------

std::string Path::toLower(const std::string& src)
{
  std::string temp;
  for(size_t i=0; i&lt;src.length(); ++i)
    temp += tolower(src[i]);
  return temp;
}
//----&lt; convert string to upper case chars &lt;---------------------------

  
std::string Path::toUpper(const std::string& src)
{
  std::string temp;
  for(size_t i=0; i&lt;src.length(); ++i)
    temp += toupper(src[i]);
  return temp;
}
//----&lt; get path from fileSpec &lt;---------------------------------------

std::string Path::getName(const std::string &fileSpec, bool withExt)
{
  size_t pos = fileSpec.find_last_of("/");
  if(pos &lt;= fileSpec.length())
  {
    pos = fileSpec.find_last_of("\\");
    if(pos &lt;= fileSpec.length())
    {
      // no path prepended
      if(withExt)
        return fileSpec;
      else
      {
        // remove ext
        size_t pos = fileSpec.find(".");
        if(pos &lt; fileSpec.size())
          return fileSpec;
        return fileSpec.substr(0, pos-1);
      }
    }
  }
  if(withExt)
    return fileSpec.substr(pos+1,fileSpec.length()-pos);
  else
  {
    // remove ext
    size_t pos2 = fileSpec.find(".", pos);
    if(pos2 &lt; fileSpec.size())
      // no ext
      return fileSpec.substr(pos+1);
    return fileSpec.substr(pos+1, pos2-pos-1);
  }
}
//----&lt; get extension from fileSpec &lt;----------------------------------
  
std::string Path::getExt(const std::string& fileSpec)
{
  size_t pos1 = fileSpec.find_last_of('/');
  size_t pos2 = fileSpec.find_last_of('\\');
  size_t pos = fileSpec.find_last_of('.');
  // handle ../ or ..\\ with no extension
  if(pos1 &lt; fileSpec.length() || pos2 &lt; fileSpec.length())
  {
    if(pos &lt; min(pos1, pos2))
      return std::string("");
  }
  // only . is extension delimiter
  if(0 &lt;= pos && pos &lt; fileSpec.length())
    return toLower(fileSpec.substr(pos+1,fileSpec.length()-pos));
  return std::string("");
}
//----&lt; get path from fileSpec &lt;---------------------------------------

std::string Path::getPath(const std::string &fileSpec)
{
  size_t pos = fileSpec.find_last_of("/");
  if(pos &lt;= fileSpec.length())
    pos = fileSpec.find_last_of("\\");
  if(pos &lt;= fileSpec.length())
    return ".";
  if(fileSpec.find(".",pos+1))
    return fileSpec.substr(0,pos+1);
  return fileSpec;
}
//----&lt; get absoluth path from fileSpec &lt;------------------------------

std::string Path::getFullFileSpec(const std::string &fileSpec)
{
  const size_t BufSize = 256;
  char buffer[BufSize];
  char filebuffer[BufSize];  // don't use but GetFullPathName will
  char* name = filebuffer;
  ::GetFullPathNameA(fileSpec.c_str(),BufSize, buffer, &name);
  return std::string(buffer);
}
//----&lt; create file spec from path and name &lt;--------------------------

std::string Path::fileSpec(const std::string &path, const std::string &name)
{
  std::string fs;
  size_t len = path.size();
  if(path[len-1] == '/' || path[len-1] == '\\')
    fs = path + name;
  else
  {
    if(path.find("/") &lt; path.size())
      fs = path + "/" + name;
    else if(path.find("\\") &lt; path.size())
      fs = path + "\\" + name;
    else
      fs = path + "/" + name;
  }
  return fs;
}
//----&lt; return name of the current directory &lt;-----------------------------

std::string Directory::getCurrentDirectory()
{
  char buffer[MAX_PATH];
  ::GetCurrentDirectoryA(MAX_PATH,buffer);
  return std::string(buffer);
}
//----&lt; change the current directory to path &lt;-----------------------------

bool Directory::setCurrentDirectory(const std::string& path)
{
  return ::SetCurrentDirectoryA(path.c_str()) != 0;
}
//----&lt; get names of all the files matching pattern (path:name) &lt;----------

std::vector&lt;std::string&lt; Directory::getFiles(const std::string& path, const std::string& pattern)
{
  std::vector&lt;std::string&lt; files;
  FileSystemSearch fss;
  std::string file = fss.firstFile(path, pattern);
  if(file.size() == 0)
    return files;
  files.push_back(file);
  while(true)
  {
    file = fss.nextFile();
    if(file.size() == 0)
      return files;
    files.push_back(file);
  }
  return files;
}
//----&lt; get names of all directories matching pattern (path:name) &lt;--------

std::vector&lt;std::string&lt; Directory::getDirectories(const std::string& path, const std::string& pattern)
{
  std::vector&lt;std::string&lt; dirs;
  FileSystemSearch fss;
  std::string dir = fss.firstDirectory(path, pattern);
  if(dir.size() == 0)
    return dirs;
  dirs.push_back(dir);
  while(true)
  {
    dir = fss.nextDirectory();
    if(dir.size() == 0)
      return dirs;
    dirs.push_back(dir);
  }
  return dirs;
}
//----&lt; create directory &lt;-------------------------------------------------

bool Directory::create(const std::string& path)
{
  return ::CreateDirectoryA(path.c_str(), NULL) == 0;
}
//----&lt; does directory exist? &lt;--------------------------------------------

bool Directory::exists(const std::string& path)
{
  DWORD dwAttrib = GetFileAttributesA(path.c_str());

  return (dwAttrib != INVALID_FILE_ATTRIBUTES && 
         (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}
//----&lt; remove directory &lt;-------------------------------------------------

bool Directory::remove(const std::string& path)
{
  return ::RemoveDirectoryA(path.c_str()) == 0;
}
//----&lt; find first file &lt;--------------------------------------------------

std::string FileSystemSearch::firstFile(const std::string& path, const std::string& pattern)
{
  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);
  if(hFindFile != INVALID_HANDLE_VALUE)
  {
    if(!(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
      return pFindFileData-&lt;cFileName;
    else
      while(::FindNextFileA(hFindFile, pFindFileData))
        if(!(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
          return pFindFileData-&lt;cFileName;
  }
  return "";
}
//----&lt; find next file &lt;---------------------------------------------------

std::string FileSystemSearch::nextFile()
{
  while(::FindNextFileA(hFindFile, pFindFileData))
    if(!(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
      return pFindFileData-&lt;cFileName;
  return "";
}
//----&lt; find first file &lt;--------------------------------------------------

std::string FileSystemSearch::firstDirectory(const std::string& path, const std::string& pattern)
{
  hFindFile = ::FindFirstFileA(Path::fileSpec(path, pattern).c_str(), pFindFileData);
  if(hFindFile != INVALID_HANDLE_VALUE)
  {
    if(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
      return pFindFileData-&lt;cFileName;
    else
      while(::FindNextFileA(hFindFile, pFindFileData))
        if(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
          return pFindFileData-&lt;cFileName;
  }
  return "";
}
//----&lt; find next file &lt;---------------------------------------------------

std::string FileSystemSearch::nextDirectory()
{
  while(::FindNextFileA(hFindFile, pFindFileData))
    if(pFindFileData-&lt;dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
      return pFindFileData-&lt;cFileName;
  return "";
}
//----&lt; test stub &lt;--------------------------------------------------------

#ifdef TEST_FILESYSTEM

void title(const std::string& title, char ch='=')
{
  std::cout &lt;&lt; "\n  " &lt;&lt; title;
  std::cout &lt;&lt; "\n " &lt;&lt; std::string(title.size()+2, ch);
}
int main(int argc, char* argv[])
{
  title("Demonstrate Path Class");

  std::string fs = Path::fileSpec(".","temp.txt");
  std::cout &lt;&lt; "\n  Path::fileSpec(\".\",\"temp.txt\") = " &lt;&lt; fs;

  std::string path = Path::getPath(fs);
  std::cout &lt;&lt; "\n  Path::getPath(\"" + fs + "\") = " &lt;&lt; path;
  
  std::string ffs = Path::getFullFileSpec(fs);
  std::cout &lt;&lt; "\n  Path::getFullFileSpec(\"" + fs + "\") = " &lt;&lt; ffs;
  
  std::string name = Path::getName(fs);
  std::cout &lt;&lt; "\n  Path::getName(\"" + fs + "\") = " &lt;&lt; name;

  std::string ext = Path::getExt(fs);
  std::cout &lt;&lt; "\n  Path::getExt(\"" + fs + "\") = " &lt;&lt; ext;

  std::string upper = Path::toUpper("temp.txt");
  std::cout &lt;&lt; "\n  Path::toUpper(\"temp.txt\") = " &lt;&lt; upper;

  std::string lower = Path::toLower("Temp.Txt");
  std::cout &lt;&lt; "\n  Path::toLower(\"Temp.Txt\") = " &lt;&lt; lower;
  std::cout &lt;&lt; std::endl;

  title("Demonstrate Directory class");

  // Display contents of current directory

  std::cout &lt;&lt; "\n  current directory is:\n    " &lt;&lt; Directory::getCurrentDirectory();
  std::cout &lt;&lt; "\n  It contains files:";
  std::vector&lt;std::string&lt; currfiles = Directory::getFiles();
  ///////////////////////////////////////////////////////
  // This works too
  // std::vector&lt;std::string&lt; currfiles = d.getFiles();  
  for(size_t i=0; i&lt;currfiles.size(); ++i)
    std::cout &lt;&lt; "\n    " &lt;&lt; currfiles[i].c_str();
  std::cout &lt;&lt; "\n  and contains directories:";
  std::vector&lt;std::string&lt; currdirs = Directory::getDirectories();
  for(size_t i=0; i&lt;currdirs.size(); ++i)
    std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str();
  std::cout &lt;&lt; "\n";

  // Display contents of non-current directory

  std::cout &lt;&lt; "\n  .txt files residing in C:/temp are:";
  currfiles = Directory::getFiles("c:/temp/", "*.txt");

  // if we want fully qualified file names, we have to
  // set the current directory to the path on which the files
  // reside, if it isn't already so set

  std::string currDir = Directory::getCurrentDirectory();
  Directory::setCurrentDirectory("c:/temp/");
  for(size_t i=0; i&lt;currfiles.size(); ++i)
    std::cout &lt;&lt; "\n    " &lt;&lt; Path::getFullFileSpec(currfiles[i]).c_str();
  Directory::setCurrentDirectory(currDir);

  // we have to restore the current directory so the
  // remaining tests work

  // it's probably easier just to use Path::fileSpec(path, filename)
  // like this:

  for (size_t i = 0; i&lt;currfiles.size(); ++i)
    std::cout &lt;&lt; "\n    " &lt;&lt; Path::fileSpec("c:\\temp\\", currfiles[i]).c_str();

  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "\n  directories residing in C:/temp are:";
  currdirs = Directory::getDirectories("c:/temp/");
  for(size_t i=0; i&lt;currdirs.size(); ++i)
    std::cout &lt;&lt; "\n    " &lt;&lt; currdirs[i].c_str();
  std::cout &lt;&lt; "\n";

  // Create directory

  title("Demonstrate FileInfo Class Operations", '=');
  std::cout &lt;&lt; "\n";

  Directory::setCurrentDirectory(".");
  std::cout &lt;&lt; "\n  current path is \"" &lt;&lt; Directory::getCurrentDirectory();
  
  std::string fn1;
  if(argc &lt; 1)
    fn1 = argv[1];
  else
    fn1 = "c:\\temp\\test.txt";
  FileInfo fi(fn1);

  if(fi.good())
  {
    std::cout &lt;&lt; "\n  name: " &lt;&lt; "\t" &lt;&lt; fi.name();
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date();
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::dateformat);
    std::cout &lt;&lt; "\n  date: " &lt;&lt; "\t" &lt;&lt; fi.date(FileInfo::timeformat);
    std::cout &lt;&lt; "\n  size: " &lt;&lt; "\t" &lt;&lt; fi.size() &lt;&lt; " bytes";
    if(fi.isArchive())
      std::cout &lt;&lt; "\n  is archive";
    else
      std::cout &lt;&lt; "\n  is not archive";
    if(fi.isCompressed())
      std::cout &lt;&lt; "\n  is compressed";
    else
      std::cout &lt;&lt; "\n  is not compressed";
    if(fi.isDirectory())
      std::cout &lt;&lt; "\n  is directory";
    else
      std::cout &lt;&lt; "\n  is not directory";
    if(fi.isEncrypted())
      std::cout &lt;&lt; "\n  is encrypted";
    else
      std::cout &lt;&lt; "\n  is not encrypted";
    if(fi.isHidden())
      std::cout &lt;&lt; "\n  is hidden";
    else
      std::cout &lt;&lt; "\n  is not hidden";
    if(fi.isNormal())
      std::cout &lt;&lt; "\n  is normal";
    else
      std::cout &lt;&lt; "\n  is not normal";
    if(fi.isOffLine())
      std::cout &lt;&lt; "\n  is offline";
    else
      std::cout &lt;&lt; "\n  is not offline";
    if(fi.isReadOnly())
      std::cout &lt;&lt; "\n  is readonly";
    else
      std::cout &lt;&lt; "\n  is not readonly";
    if(fi.isSystem())
      std::cout &lt;&lt; "\n  is system";
    else
      std::cout &lt;&lt; "\n  is not system";
    if(fi.isTemporary())
      std::cout &lt;&lt; "\n  is temporary";
    else
      std::cout &lt;&lt; "\n  is not temporary";
  }
  else
    std::cout &lt;&lt; "\n  filename " &lt;&lt; fn1 &lt;&lt; " is not valid in this context\n";

  std::string fn2;
  if(argc &lt; 2)
  {
    fn1 = argv[1];
    fn2 = argv[2];
  }
  else
  {
    fn1 = "FileSystem.h";
    fn2 = "FileSystem.cpp";
  }
  FileInfo fi1(fn1);
  FileInfo fi2(fn2);
  if(fi1.good() && fi2.good())
  {
    if(fi1 == fi1)
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi1.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi1.name();
    if(fi1 &lt; fi1)
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi1.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt;= " &lt;&lt; fi1.name();
    if(fi1 == fi2)
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " == " &lt;&lt; fi2.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " != " &lt;&lt; fi2.name();
    if(fi1 &lt; fi2)
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt; " &lt;&lt; fi2.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " &lt;= " &lt;&lt; fi2.name();
    if(fi1.smaller(fi2))
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is smaller than " &lt;&lt; fi2.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not smaller than " &lt;&lt; fi2.name();
    if(fi1.earlier(fi2))
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is earlier than " &lt;&lt; fi2.name();
    else
      std::cout &lt;&lt; "\n  " &lt;&lt; fi1.name() &lt;&lt; " is not earlier than " &lt;&lt; fi2.name();
    std::cout &lt;&lt; std::endl;
  }
  else
    std::cout &lt;&lt; "\n  files " &lt;&lt; fn1 &lt;&lt; " and " &lt;&lt; fn2 &lt;&lt; " are not valid in this context\n";

  title("Demonstrate File class operations", '=');
  std::cout &lt;&lt; "\n";

  // copy binary file from one directory to another

  File me("../debug/filesystemdemo.exe");
  me.open(File::in, File::binary);
  std::cout &lt;&lt; "\n  copying " &lt;&lt; me.name().c_str() &lt;&lt; " to c:/temp";
  if(!me.isGood())
  {
    std::cout &lt;&lt; "\n  can't open executable\n";
    std::cout &lt;&lt; "\n  looking for:\n  ";
    std::cout &lt;&lt; Path::getFullFileSpec(me.name()) &lt;&lt; "\n";
  }
  else
  {
    File you("c:/temp/fileSystemdemo.exe");
    you.open(File::out, File::binary);
    if(you.isGood())
    {
      while(me.isGood())
      {
        static size_t count = 0;
        Block b = me.getBlock(1024);
        you.putBlock(b);
        if (++count &lt; 10)
        {
          std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes";
          std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes";
        }
        if (b.size() &lt; 1024)
        {
          std::cout &lt;&lt; "\n\n    omitted " &lt;&lt; count-10 &lt;&lt; " blocks from display\n\n";
          std::cout &lt;&lt; "\n    reading block of " &lt;&lt; b.size() &lt;&lt; " bytes";
          std::cout &lt;&lt; "\n    writing block of " &lt;&lt; b.size() &lt;&lt; " bytes";
        }
      }
      std::cout &lt;&lt; "\n";
    }
  }

  // save some filespecs of text files in a vector for File demonstrations

  std::vector&lt;std::string&lt; files;
  if(argc == 1)
  {
    std::cout &lt;&lt; "\n\n  Enter, on the command line, an additional filename to process.\n";
  }

  for(int i=1; i&lt;argc; ++i)
  {
    files.push_back(argv[i]);
  }
  files.push_back("FileSystem.cpp");                     // file not on current path
  files.push_back("../FileSystemDemo/FileSystem.cpp");   // file from project directory
  files.push_back("../FileSystemTest.txt");              // file in solution directory
  files.push_back("foobar");                             // doesn't exist

  // open each file and display a few lines of text

  for(size_t i=0; i&lt;files.size(); ++i)
  {
    File file(files[i]);
    file.open(File::in);
    if(!file.isGood())
    {
      std::cout &lt;&lt; "\n  Can't open file " &lt;&lt; file.name();
      std::cout &lt;&lt; "\n  Here's what the program can't find:\n  " &lt;&lt; Path::getFullFileSpec(file.name()); 
      continue;
    }
    std::string temp = std::string("Processing file ") + files[i];
    title(temp, '-');
    for(int j=0; j&lt;10; ++j)
    {
      if(!file.isGood())
        break;
      std::cout &lt;&lt; "\n  -- " &lt;&lt; file.getLine().c_str();
    }
    std::cout &lt;&lt; "\n";
  }
  std::cout &lt;&lt; "\n";

  // read all lines of text file into string

  title("testing File::readAll()", '-');
  std::cout &lt;&lt; "\n";
  File testAll("../FileSystemTest.txt");
  testAll.open(File::in);
  if (testAll.isGood())
  {
    std::string all = testAll.readAll();
    std::cout &lt;&lt; all &lt;&lt; "\n";
  }
  testAll.close();

  title("testing File::readAll(true)", '-');
  std::cout &lt;&lt; "\n";
  File testAllTrue("../FileSystemTest.txt");
  testAllTrue.open(File::in);
  if (testAllTrue.isGood())
  {
    std::string all = testAllTrue.readAll(true);
    std::cout &lt;&lt; all &lt;&lt; "\n";
  }
  testAllTrue.close();

  // test reading non-text files

  title("test reading non-text files", '-');
  std::cout &lt;&lt; "\n  Attempting to open Visual Studio files.";
  std::cout &lt;&lt; "\n  These are locked by VS when running from IDE.";
  std::cout &lt;&lt; "\n  They will open if you run FileSystemDemo from the debug folder,";
  std::cout &lt;&lt; "\n  provided you've closed the solution in VS.\n";
  std::cout &lt;&lt; "\n";
  std::string testPath = "./debug";  // run from project directory (what Visual Studio does)
  if (!Directory::exists(testPath))
    testPath = ".";                  // run from solution debug directory
  std::vector&lt;std::string&lt; testFiles = Directory::getFiles(testPath);
  for (auto file : testFiles)
  {
    try
    {
      std::string ext = Path::getExt(file);
      if (ext == "exe" || ext == "obj" || ext == "dll" || file == "run.dat")
      {
        /* reading binary file works, but generates a lot of garbage */
        /* I use run.dat to capture this output so including will make output confusing */

        std::cout &lt;&lt; "  skipping binary file " &lt;&lt; file &lt;&lt; "\n";
        continue;
      }
      File test(file);
      test.open(File::in);  // open as text file
      std::cout &lt;&lt; "\n  processing \"" &lt;&lt; file &lt;&lt; "\"\n";
      if (test.isGood())
      {
        std::string text = test.readAll(true);
        std::cout &lt;&lt; text &lt;&lt; "\n";
      }
      else
      {
        std::cout &lt;&lt; "\n  open failed\n";
      }
    }
    catch (std::exception& ex)
    {
      std::cout &lt;&lt; "\n  Exception: " &lt;&lt; ex.what() &lt;&lt; "\n";
    }
  }

  // read text file and write to another text file

  title("writing to c:/temp/test.txt", '-');
  File in("../FileSystemDemo/FileSystem.h");
  in.open(File::in, File::text);
  File out("c:/temp/test.txt");
  out.open(File::out, File::text);
  while(in.isGood() && out.isGood())
  {
    std::string temp = in.getLine();
    //std::cout &lt;&lt; "\n  " &lt;&lt; temp.c_str();
    out.putLine(temp);
    out.putLine("\n");
  }
  std::cout &lt;&lt; "\n  check c:/temp/test.txt to validate";
  std::cout &lt;&lt; "\n\n";

  // read and write buffers

  title("reading and writing buffers");
  std::cout &lt;&lt; "\n  " &lt;&lt; FileSystem::Directory::getCurrentDirectory();
  std::string fileIn = "../TestFileSystem/UnitTest.h";
  std::string fileOut = "../TestFileSystem/CopyOfUnitTest.h";
  File bufferIn(fileIn);
  bufferIn.open(File::in, File::binary);
  if (!bufferIn.isGood())
  {
    std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileIn &lt;&lt; "\" for reading";
      return 1;
  }
  else
  {
    std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileIn &lt;&lt; "\" for reading";
  }
  File bufferOut(fileOut);
  bufferOut.open(File::out, File::binary);
  if (!bufferOut.isGood())
  {
    std::cout &lt;&lt; "\n  could not open \"" &lt;&lt; fileOut &lt;&lt; "\" for writing\n\n";
      return 1;
  }
  else
  {
    std::cout &lt;&lt; "\n  opening: \"" &lt;&lt; fileOut &lt;&lt; "\" for writing";
  }
  std::cout &lt;&lt; "\n";
  const size_t bufLen = 124;
  File::byte buffer[bufLen];
  while (true)
  {
    size_t resultSize = bufferIn.getBuffer(bufLen, buffer);
    //std::cout &lt;&lt; "\n  reading buffer of size " &lt;&lt; resultSize &lt;&lt; " bytes";
    std::string temp1(buffer, resultSize);
    std::cout &lt;&lt; temp1;
    //std::cout &lt;&lt; "\n  writing buffer of size " &lt;&lt; resultSize &lt;&lt; "bytes";
    bufferOut.putBuffer(resultSize, buffer);
    if (resultSize &lt; bufLen || !bufferIn.isGood() || !bufferOut.isGood())
    {
      bufferIn.close();
      bufferOut.close();
      break;
    }
  }
  std::cout &lt;&lt; "\n\n";
}
#endif
</pre>
</body>
</html>
